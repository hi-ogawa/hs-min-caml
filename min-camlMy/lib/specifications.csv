アーキテクチャ名	myArchitecture
バイナリファイルのエンディアン	リトルエンディアン
ROM（命令メモリを格納する領域）サイズ	64KB(固定)
ROMアドレッシング	ワードアドレッシング
RAM（プログラム実行時の作業用領域）サイズ	8.00
RAMアドレッシング	ワードアドレッシング
コメントアウト記号	!
整数レジスタ接頭辞	r
浮動小数レジスタ接頭辞	f
整数レジスタ数	32
浮動小数レジスタ数	32
キャッシュに使う浮動小数レジスタ数	16
ゼロレジスタ	$r0
フレームレジスタ	$r1
ヒープレジスタ	$r28
リンクレジスタ	$r31
1固定レジスタ	$r30
-1固定レジスタ	$r31


命令形式
R	op(6bit)	rs(5bit)	rt(5bit)	rd(5bit)	shamt(5bit)	funct(5bit)
I	op(6bit)	rs(5bit)	rt(5bit)	imm(16bit)
J	op(6bit)	target(26bit)


命令名	説明	命令形式	アセンブリ形式	擬似コード	op						funct
add	たし算	R	add rd, rs, rt	rd <- rs + rt	0	0	0	0	0	0	0	0	0	0	0	0
sub	ひき算	R	sub rd, rs, rt	rd <- rs - rt	0	0	0	0	0	0	0	0	0	0	0	1
and	論理積	R	and rd, rs, rt	rd <- rs & rt	0	0	0	0	0	0	0	0	1	0	0	1
or	論理和	R	or rd, rs, rt	rd <- rs | rt	0	0	0	0	0	0	0	0	1	0	1	0
nor	論理否定和	R	nor rd, rs, rt	rd <- rs nor rt	0	0	0	0	0	0	0	0	1	0	1	1
xor	排他的論理和	R	xor rd, rs, rt	rd <- rs xor rt	0	0	0	0	0	0	0	0	1	1	0	0
mvlo	下位16bitに即値代入	I	mvlo rt, imm	rt[0:15] <- imm	0	1	0	0	0	1	
mvhi	上位16bitに即値代入	I	mvhi rt, imm	rt[16:31] <- imm	0	1	0	0	1	0	
addi	たし算	I	addi rt, rs, imm	rt <- rs + imm	0	0	0	1	0	0	
subi	ひき算	I	subi rt, rs, imm	rt <- rs - imm	0	0	0	1	0	1	
slli	論理左シフト	I	slli rt, rs, imm	rt <- rs << imm	0	0	1	0	0	0	
srai	算術右シフト	I	srai rt, rs, imm	rt <- rs >> imm	0	0	1	0	1	1	
fmov	値の複製	R	fmov frd, frs	frd <- frs	0	0	0	0	1	0	0	0	0	0	0	1
fneg	符号反転	R	fneg frd, frs	frd <- -frs	0	0	0	0	0	1	0	0	0	0	0	0
fadd	たし算	R	fadd frd, frs, frt	frd <- frs + frt	0	0	0	0	0	1	0	0	0	0	0	1
fsub	ひき算	R	fsub frd, frs, frt	frd <- frs - frt	0	0	0	0	0	1	0	0	0	0	1	0
fmul	かけ算	R	fmul frd, frs, frt	frd <- frs * frt	0	0	0	0	0	1	0	0	0	0	1	1
fdiv	わり算	R	fdiv frd, frs, frt	frd <- frs / frt	0	0	0	0	0	1	0	0	0	1	0	1
fsqrt	平方根	R	fsqrt frd, frs	frd <- fsqrt(frs)	0	0	0	0	0	1	0	0	1	0	0	1
ldi	メモリから整数レジスタへロード	I	ldi rt, rs, imm	rt <- RAM[rs + imm]	1	0	1	0	0	0	
sti	整数レジスタをメモリへストア	I	sti rt, rs, imm	RAM[rs + imm] <- rt	1	0	1	0	0	1	
fldi	メモリから浮動小数レジスタへロード	I	fldi frt, rs, imm	frt <- RAM[rs + imm]	1	0	1	0	1	0	
fsti	浮動小数レジスタをメモリへストア	I	fsti frt, rs, imm	RAM[rs + imm] <- frt	1	0	1	0	1	1	
beq	等しい	I	beq rs, rt, imm	if rs == rt then goto (pc + imm)	0	1	0	1	1	0	
bne	等しくない	I	bne rs, rt, imm	if rs != rt then goto (pc + imm)	0	1	0	1	1	1	
blt	より小さい	I	blt rs, rt, imm	if rs < rt then goto (pc + imm)	0	1	1	0	0	0	
bgt	より大きい	I	bgt rs, rt, imm	if rs > rt then goto (pc + imm)	0	1	1	0	0	1	
ble	以下	I	ble rs, rt, imm	if rs <= rt then goto (pc + imm)	0	1	1	0	1	0	
bge	以上	I	bge rs, rt, imm	if rs >= rt then goto (pc + imm)	0	1	1	0	1	1	
fbeq	等しい	I	fbeq frs, frt, imm	if frs == frt then goto (pc + imm)	0	1	1	1	0	0	
fbne	等しくない	I	fbne frs, frt, imm	if frs != frt then goto (pc + imm)	0	1	1	1	0	1	
fblt	より小さい	I	fblt frs, frt, imm	if frs < frt then goto (pc + imm)	0	1	1	1	1	0	
fbgt	より大きい	I	fbgt frs, frt, imm	if frs > frt then goto (pc + imm)	0	1	1	1	1	1	
fble	以下	I	fble frs, frt, imm	if frs <= frt then goto (pc + imm)	1	0	0	0	0	0	
fbge	以上	I	fbge frs, frt, imm	if frs >= frt then goto (pc + imm)	1	0	0	0	0	1	
j	ラベルへジャンプ	J	j labelName	goto labelName	0	1	0	1	0	1	
jr	レジスタ値へジャンプ	R	jr rs	goto rs	1	0	0	0	1	0	0	0	0	0	0	0
jal	リンクしてラベルへジャンプ	J	jal labelName	link register <- pc; goto labelName	1	0	0	0	1	1	
jalr	リンクしてレジスタ値へジャンプ	R	jalr rs	link register <- pc; goto rs	1	0	0	1	0	0	0	0	0	0	0	0
inputb	1byte読み込み	R	inputb rd	rd <- ReadByte()	0	0	0	0	1	1	0	0	0	0	0	0
outputb	1byte書き出し	R	outputb rs	WriteByte(rs & 0xf)	0	0	0	0	1	1	0	0	0	0	1	1
halt	プログラムを終了	R	halt  		0	0	0	0	1	1	0	0	0	1	1	0


ニーモニック（擬似命令）	説明		アセンブリ形式	擬似コード
nop	なにもしない		nop	 
mov	レジスタ値の複製		mov rd, rs	rd <- rs
not	ビット反転		not rd, rs	rd <- not rs
neg	符号反転		neg rd, rs	rd <- -rs
setl	ラベル値をレジスタに代入		setl rt, labelName	rt <- labelAddress
fliw	浮動小数レジスタへ32ビット即値代入		fliw rd, float_imm	rd <- float_imm
