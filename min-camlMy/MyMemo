<<命令数の遷移をメモしましょう>>

(-inline 53)
inst_num: 3745647396

(-inline 52) (+elimEqExp)
inst_num: 3574248034

(-inline 53) (+elimEqExp)
inst_num: 3521894250

(-inline 54) (+elimEqExp)
inst_num: 3521894250
				(50, elimExExp)     (50, print-binary, elimExExp)   << instStatistics >>  <<sqrt無し、-50,elimEqExp >>  (haskell)       << instStatistics >>
#define HALT	0		 0:          1	     0:          1		     0:          1	   0:          1	       0:          1 	 0:          1	    
#define AND	1		 1:          0	     1:          0		     1:          0	   1:          0	       1:          0 	 1:          0	    
#define ADDU	2		 2:  104790189	     2:   92841059		     2:   91109051	   2:   92841059	       2:  110075422 	 2:   98504381	    
#define SUBU	3		 3:   29132986	     3:      75708		     3:      75599	   3:      75708	       3:   29132986 	 3:      75708	    
#define SLT	4		 4:    6604963	     4:    2912009		     4:    2916494	   4:    2912009	       4:    7002103 	 4:    2912142	    
#define LW	5		 5:  849429555	     5:  818526253		     5:  798895966	   5:  818526253	       5: 2051729248 	 5:  771224241	    
#define SW	6		 6:  385001265	     6:  356633392		     6:  345645659	   6:  356633392	       6:  339399585 	 6:  309643544	    
#define BEQ	7		 7:          0	     7:          0		     7:          0	   7:          0	       7:          0 	 7:          0	    
#define BNE	8		 8:  295244118	     8:  233602595		     8:  212506502	   8:  233602595	       8:  352661793 	 8:  233602752	    
#define ADDI	9		 9:  497247397	     9:  440662934		     9:  399357772	   9:  440662934	       9:  765642813 	 9:  555909850	    
#define ORI	10		10:     301832	    10:     105223		    10:     105223	  10:     105223	      10:     498551 	10:     105339	    
#define SLL	11		11:  147939607	    11:   92826891		    11:   91094855	  11:   92826891	      11:  153273945 	11:   98490166	    
#define SRA	12		12:   28714968	    12:       1754		    12:       1685	  12:       1754	      12:   56248430 	12:       3458	    
#define LUI	13		13:     279472	    13:      82863		    13:      82863	  13:      82863	      13:     476191 	13:      82979	    
#define JR	14		14:   93483024	    14:   83290285		    14:   76748125	  14:   83290285	      14:   98342690 	14:   87799091	    
#define INPUT	15		15:       1137	    15:       1137		    15:       1137	  15:       1137	      15:       1137 	15:       1137	    
#define OUTPUT	16		16:     154737	    16:      49167		    16:      49167	  16:      49167	      16:     154737 	16:      49167	    
#define J	17		17:  130786182	    17:  119201831		    17:  122745456	  17:  119201831	      17:  155894362 	17:  118663640	    
#define JAL	18		18:   51240757	    18:   41056210		    18:   35839332	  18:   41056210	      18:   52867138 	18:   42825231	    
#define ADDS	19		19:   59947175	    19:   59947175		    19:   60145173	  19:   59947175	      19:   59947175 	19:   59943175	    
#define SUBS	20		20:   98385161	    20:   98385161		    20:   54964134	  20:   98385161	      20:   98390094 	20:   98383211	    
#define MULS	21		21:  161064158	    21:  161064158		    21:  117798264	  21:  161064158	      21:  161064208 	21:  161062208	    
#define DIVS	22		22:   23370289	    22:   23370289		    22:    1559312	  22:   23370289	      22:   23370289 	22:   23370289	    
#define FMOVE	23		23:   17873483	    23:   17873483		    23:   12819848	  23:   17873483	      23:   17897925 	23:   17873276	    
#define FNEG	24		24:   18759928	    24:   18759928		    24:   18833568	  24:   18759928	      24:   18760529 	24:   18760529	    
#define CEQS	25		25:   11158189	    25:   11158189		    25:   11192295	  25:   11158189	      25:   11158214 	25:   11158214	    
#define CLES	26		26:   76166244	    26:   76166244		    26:   76493415	  26:   76166244	      26:   76176010 	26:   76164244	    
#define LFL	27		27:   42096253	    27:   42096253		    27:   37874273	  27:   42096253	      27:   72081322 	27:   72064673	    
#define LFH	28		28:   42096253	    28:   42096253		    28:   37874273	  28:   42096253	      28:   72081322 	28:   72064673	    
#define LWCL	29		29:  279923702	    29:  279923702		    29:  271834269	  29:  279923702	      29:  277072995 	29:  277033473	    
#define SWCL	30		30:   39464915	    30:   39464915		    30:   31700993	  30:   39464915	      30:   36908411 	30:   36898645	    
#define BCLT	31		31:          0	    31:          0		    31:          0	  31:          0	      31:          0 	31:          0	    
#define BCLF	32		32:   87324433	    32:   87324433		    32:   87685710	  32:   87324433	      32:   87334224 	32:   87322458	    
#define SQRT	33		33:          0      33:          0		    33:    2197817	  33:          0	      33:          0 	33:          0	    
										    inst_num: 3000148231  inst_num: 3239499495	      ALL: 5185643850	inst_num: 3331991895



各ステージでどのような変換が行われているか、そのなかで特に注意する点などをメモ。
また、自作ISAように移植する際に省いたほうが良い、もしくは、追加するべき処理を書いていく。
			
     			
(0) Lexer,Parser	
(1) Typing	(型推論: 型による不整合をチェック)
(2) KNormal	(K正規化: ネストした式を減らす (この時点ではIf,Let,Letrec,LetTupleのみ入れ子))
(3) Alpha	(α変換: 異なる変数に異なる名前をつける)
(4) Beta	(β簡約: 同じ変数を一つに置換)
(5) Assoc	(Letの入れ子をなくす)
(6) Inline	(インライン展開)
(7) ConstFold	(定数畳込み)
(8) Elim	(不要定義削除)
(9) Closure	(クロージャ変換: Letrecの入れ子をなくす)
(10) Virtual	(仮想コード生成)
(11) Simm	(即値最適化: レジスタオペランドをimmediateをオペランドに変える)
(12) RegAlloc	(レジスタ割り当て: )
(13) Emit	(アセンブリ出力)
			
			
			
(0) ->  [Syntax.t]  -> (1) -> (2) ->  [KNormal.t]  -> (3) -....-> (9) ->  [Closure.t] (fundef list, exp)
  -> (10) ->  [Virtual.t] (float_data, fundefs, exp)  -> (11) -..->(13) -> アセンブリ出力
			
			
			
(10)			
			
(11) 条件分岐の比較引数の即値最適化は外す(自作ISAには即値オペランドを取れないから)
			
(12) レジスタ割り当てを自作ISA用に(実際はAsm.ml書き換え)
			
	     <SPARCのレジスタと自作CPUのレジスタの対応>
			--SPARC------------------------		--自作ISA-------------------
汎用レジスタ(regs)	%i2 - %i7, %l0 - %l7, %o0 - %o5		%r2 - %r27 (適当)
浮動小数点(fregs)	%f0,%f2,.., %f30 (64bitが16個)		%f0 - %f31
stack pointer(reg_sp)	%i0					%r29
heap pointer(reg_hp)	%i1					%r30
return addres(reg_ra)	%o7					%r31

関数の引数		%i2 - 全部, %f0 - 全部			%r2 - 全部, %f0 - 全部
関数の戻り値		%i2, %f0				%r2, %f0
closure pointer(reg_cl)	%o5					%r28
swap reg		%o4					%r27

補足								r0は常にゼロ, r1はアセンブリの遊び
								(シフトで代用できる疑惑)
								r20: closure

<メモ>
関数呼び出しに伴いスタックはアドレスの大きい方に伸ばしていく
フロートは単精度
全部caller-save


(13) subi命令がないので、即値の引き算はaddiuで代用。
SLL のレジスタオペランドどうする	<= array中の計算のための即値オフセットしかないから大丈夫
SetLどうする (FLoat table, MakeCls, ExtArrayで必要) <= load address 擬似命令で対応
Ld, LdDF, St, StDF のレジスタオペランドどうする(配列中の計算で必要となる)	<= 事前にオフセットを足せばOK
関数呼び出し後の遅延スロットは外す <= はずした

即値に負が来るのはあり得る??(負ならばNegがかかった変数になってそう)
即値に負が来れるように最適化する(あとで)

定数たたみ込みで32bit整数を超えることがありそう??(一応チェックする、あとで)

