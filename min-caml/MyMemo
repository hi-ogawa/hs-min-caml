各ステージでどのような変換が行われているか、そのなかで特に注意する点などをメモ。
また、自作ISAように移植する際に省いたほうが良い、もしくは、追加するべき処理を書いていく。

     
(0) Lexer,Parser
(1) Typing	(型推論: 型による不整合をチェック)
(2) KNormal	(K正規化: ネストした式を減らす (この時点ではIf,Let,Letrec,LetTupleのみ入れ子))
(3) Alpha	(α変換: 異なる変数に異なる名前をつける)
(4) Beta	(β簡約: 同じ変数を一つに置換)
(5) Assoc	(Letの入れ子をなくす)
(6) Inline	(インライン展開)
(7) ConstFold	(定数畳込み)
(8) Elim	(不要定義削除)
(9) Closure	(クロージャ変換: Letrecの入れ子をなくす)
(10) Virtual	(仮想コード生成)
(11) Simm	(即値最適化: レジスタオペランドをimmediateをオペランドに変える)
(12) RegAlloc	(レジスタ割り当て: )
(13) Emit	(アセンブリ出力)



(0) ->  [Syntax.t]  -> (1) -> (2) ->  [KNormal.t]  -> (3) -....-> (9) ->  [Closure.t] (fundef list, exp)
  -> (10) ->  [Virtual.t] (float_data, fundefs, exp)  -> (11) -..->(13) -> アセンブリ出力



(10)

(11) 条件分岐の比較引数の即値最適化は外す(自作ISAには即値オペランドを取れないから)

(12) レジスタ割り当てを自作ISA用に(実際はAsm.ml書き換え)

	     <SPARCのレジスタと自作CPUのレジスタの対応>
			--SPARC------------------------		--自作ISA-------------------
汎用レジスタ(regs)	%i2 - %i7, %l0 - %l7, %o0 - %o5		%r2 - %r27 (適当)
浮動小数点(fregs)	%f0,%f2,.., %f30 (64bitが16個)		%f0 - %f31
stack pointer(reg_sp)	%i0					%r29
heap pointer(reg_hp)	%i1					(%r28)
return addres(reg_ra)	%o7					%r31

関数の引数		%i2 - 全部, %f0 - 全部			r2 - 全部, f0 - 全部
関数の戻り値		%i2, %f0				r2, f0
closure pointer(reg_cl)	%o5					r27

補足								r0は常にゼロ
			caller-saveやら謎(使うものは退避?)	Hi, Lo レジスタ使う?(整数乗算、除算の結果)
								(シフトで代用できる疑惑)


(13) subi命令がないので、即値の引き算はaddiuで代用。


どこでやってるか分からないけど
(??) 関数呼び出し後の遅延スロットは外す