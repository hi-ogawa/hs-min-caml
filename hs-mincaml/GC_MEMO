- coping GC (Cheneyのやつ) -
正確なGC
* rootを正確に把握する。
 - レジスタ、スタック中のポインタ。
 - スタック:(現在のSP)~(SPの最大値)に間を詮索すればOK?
   現在のスタックフレームにおいてどれだけ積み上げてるかが分からないのでどうするか。
   スタック積むごとに変化させるレジスタを追加したほうが楽かな(処理が重くなりそう。if前の退避は一気にできる)
 - データ型: 32bit Integer, 32bit float, 32bit ponter(配列、タプルへの参照。あとクロージャも)
 - レジスタやメモリに格納された値がpointerであるかどうかを判定するために下位1bitをタグとする。
   0: pointer
   1: value of int or float
 - 配列、タプル、クロージャのheaderに必要な情報は?
   object size
   forwarding pointer (copied flagはCheneyの方法だといらない)
 - compilerとして変更する部分
   Virtual以降のみ??
   libasm.s: 配列生成部分。(headerを加える)
   Virtual: makecls, tuple, lettuple, get, put のアクセス部分と生成部分を変える。
   create_array, makecls, tupleにおけるオブジェクト生成時にGC走らせるかどうかの分岐を仕込む。
   tag関連の処理をどこでするか。
   Emit: <float>は常に下位1bitが「1」になるように上書きする。(即値としてレジスタに置くとき。小数演算したものをレジスタに返すとき。比較はそのままでOK)
   	 <int>はシフトで精度を保つように下位を「1」にする。(以下の例を参照)
	 <pointer>はそのままでよい。(32bit alignmentなので下位の2bitは「00」になってる)
	 定数レジスタもそれに従った感じに!!
   アセンブラライブラリも注意。

 - とりあえずglobal配列、タプルは無視して実装する

- メモリ領域の設定 -
all memory: 2 ^ 22 bytes (pointer)
   0x000000 番地
 ~ 0x3FFFFF 番地


- intに対するシフトの例(emitの上でちょこちょこ変える) -
実質、上から2bit目(sign bitの次のbit)は無視する。
即値命令系は注意。
即値代入
即値比較(普通の比較はそのままでok)
neg, add, sub, sll, sra

r2 <- 14            (sign:0 -  1110)を(sign:0 -  11101)として代入
r3 <- 25            (sign:0 - 11001)を(sign:0 - 110011)として代入
r4 <- r2 + r3       
 - r2, r3を元の値に戻してから「+」命令を行い、その後r4, r2, r3共に上と同様に加工してレジスタに戻す。
r4 <- r2 - r3       
 - 「+」の時と同様。

 - 負の整数の変換: 
 signは保存。
 1~30bitを2~31bitに置き換える。
 1bit目に「1」を立てる。
 保存しといたsignを戻す。